<!DOCTYPE html>
<html lang="en">
    <head>
        <title>EENG 484</title>
        <meta name="description" content="EENG 484 - Advanced Digital Design">
        <meta name="author" content="Christopher Coulston">
  	<meta name="viewport" content="width=device-width, initial-scale=1">
  	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css">
  	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
  	<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js"></script>
    </head>
    <body>

        <div class = "container">
            <div class = "navbar navbar-inverse">
                <div class = "navbar-inner">
                    <a class = "brand" href="../../index.html">EENG 484</a>
                    <ul class="nav pull-right">
                        <li><a href="../lab01/lab01.html">&ltPrev</a></li>
                        <li><a href="../lab03/lab03.html">Next&gt</a></li>
                    </ul>
                </div>
            </div>


<h1>Lab 2 - Signal Display to HDMI</h1>

In this lab, you will write a HDMI Video controller in VHDL and implement 
it on your FPGA development board.  You will be provided a VGA-to-HDMI 
module that will automatically format your output for the HDMI output 
port on your development board.  This HDMI video controller will be tasked 
to generate the display portion of an oscilloscope as shown in the
figure below.  The scope face consists of a white grid, used to 
measure the signals, two trigger markers, and the waveforms.  In
this lab the waveforms will be artificially generated by your code,
but in later labs, the waveforms will be generated by incoming
audio waveforms.

<br><img src="./img/layout.jpg" alt="Figure 3"><br><br>



<h2>Architecture</h2>
The design of the lab is broken down into separate modules, some of which
are provided for you and some which you will need to create.  The
interconnection of the modules is illustrated in the following schematic.
When a signal name appears just inside a box, that should should correspond
to the name of that signal in the entity description.  Please note
there are a few omissions in the diagram that you should correct
as part of your documentation (see Turn-In section).

<br><img src="./img/lab1Architecture.png"><br><br>


<h2>VHDL Code</h2>
In order to get you going in this lab, some of the VHDL code has been 
provided for you. In most cases, you should refrain from changing the
modules given.  In order to get a better understanding how these modules 
interact with one another, the following section provides a schematic
and the input, output and behavior of some of the modules.


<ul>	<li><a href="./code/scopeToHdmi.vhdl">scopeToHdmi.vhdl</a>
	<li><a href="./code/scopeToHdmi_tb.vhd">scopeToHdmi_tb.vhd</a>
	<li><a href="./code/scopeToHdmi_package.vhd">scopeToHdmi_package.vhd</a>
	<li><a href="./code/scopeFace.vhd">scopeFace.vhd</a>
	<li><a href="./code/videoSignalGenerator.vhdl">videoSignalGenerator.vhdl</a>
	<li><a href="./code/scopeToHdmi_tbWaveSetup.tcl">scopeToHdmi_tbWaveSetup.tcl</a>
	<li><a href="./code/scopeToHdmi.xdc">scopeToHdmi.xdc</a>
	<li><a href="https://www.realdigital.org/doc/715356000ec89fbfd26a44cd2444659b">
		VGA to HDMI IP core</a>   
</ul>

There are two modules which will constitute the majority of your work, videoSignalGenerator
and scopeFace.  The following two subsections details the behavior of these
two modules.


<h3>The videoSignalGenerator module</h3>
The videoSignalGenerator component generates the signals to sweep the 
display beam across the display from left to right, and from top to
bottom.  The scopeFace component will take the pixelHorz and pixelVert
values and determine what color pixel to place at that location.

<pre>
entity videoSignalGenerator is
    PORT(
	 clk: in  STD_LOGIC;
         resetn : in  STD_LOGIC;
         hs: out STD_LOGIC;
         vs: out STD_LOGIC;
         de: out STD_LOGIC;
         pixelHorz: out STD_LOGIC_VECTOR(VIDEO_WIDTH_IN_BITS-1 downto 0);
         pixelVert: out STD_LOGIC_VECTOR(VIDEO_WIDTH_IN_BITS-1 downto 0));
end videoSignalGenerator;
</pre>

<table class="table table-striped table-bordered table-condensed">
<tr><td>clk	<td>This is the 74.25Mhz videoClk generated by the video_clk component.
<tr><td>resetn	<td>This is the same active low reset signal passed into the top
			level Lab1 module.
<tr><td>hs	<td>The h_synch signal for the current row,column position.
<tr><td>vs	<td>The v_synch signal for the current row,column position.
<tr><td>de	<td>The blank signal for the current row,column position.  Its
			the logical and of the h_blank and v_blank signals.
<tr><td>pixelHorz<td>The current row on the display that needs a RGB value from this component.
<tr><td>pixelVert<td>The current column on the display that needs a RGB value from this component.
</table>


The behavior of the videoSignalGenerator component contains counters which generate:
<ul>	<li>h_cnt and v_cnt
	<li>hs and vs
	<li>pixelHorz and pixelVert
	<li>h_activeArea and v_activeArea
</ul>
 
<h3>The scopeFace module</h3>
This component takes in the horizontal and vertical pixel location from the 
videoSignalGenerator component and determines the R,G,B value of the pixel
that should be drawn at that location.

<pre>
entity scopeFace is
    PORT (
  	 clk: in  STD_LOGIC;
         resetn : in  STD_LOGIC;
         pixelHorz : in  STD_LOGIC_VECTOR(VIDEO_WIDTH_IN_BITS-1 downto 0);
         pixelVert : in  STD_LOGIC_VECTOR(VIDEO_WIDTH_IN_BITS-1 downto 0);
         triggerVolt: in STD_LOGIC_VECTOR (VIDEO_WIDTH_IN_BITS-1 downto 0);
         triggerTime: in STD_LOGIC_VECTOR (VIDEO_WIDTH_IN_BITS-1 downto 0);
         red : out  STD_LOGIC_VECTOR(7 downto 0);
         green : out  STD_LOGIC_VECTOR(7 downto 0);
         blue : out  STD_LOGIC_VECTOR(7 downto 0);
         ch1: in STD_LOGIC;
         ch1Enb: in STD_LOGIC;
         ch2: in STD_LOGIC;
         ch2Enb: in STD_LOGIC);
end scopeFace;
</pre>

<table class="table table-striped table-bordered table-condensed">
<tr><td>clk	<td>This is the 25Mhz pixel clock generated by the DCM in 
			the video module.
<tr><td>resetn	<td>This is the same active low reset signal passed into the top level component.
<tr><td>pixelVert	<td>The current row on the display that needs a RGB value from this
				component.
<tr><td>pixelHorz	<td>The current column on the display that needs a RGB value from this
				component.
<tr><td>triggerVolt	<td>This is a 12-bit value representing the trigger 
			voltage.  This value is passed to the scopeFace module
			so that a yellow arrow (see Trigger Level Marker in the
			screen show) on the vertical axis.
<tr><td>triggerTime	<td>This is a 12-bit value representing the trigger 
			time.  This value is passed to the scopeFace module
			so that a yellow arrow (see Trigger Time Marker in the
			screen show) on the horizontal axis.
<tr><td>red	<td>The 8-bit red intensity for this row,column pixel on the screen.
<tr><td>green	<td>The 8-bit green intensity for this row,column pixel on the screen.
<tr><td>blue	<td>The 8-bit blue intensity for this row,column pixel on the screen.
<tr><td>ch1	<td>This 1-bit signal causes a yellow channel 1 trace to be drawn
			on the display at the current pixel location. When this
			signal is 0, no channel 1 pixel is drawn.
<tr><td>ch1enb	<td>This 1-bit signal enable the ch1 signal to be drawn.
<tr><td>ch2	<td>This 1-bit signal causes a green channel 2 trace to be drawn
			on the display at the current pixel location. When this
			signal is 0, no channel 2 pixel is drawn.
<tr><td>ch2enb	<td>This 1-bit signal enable the ch2 signal to be drawn.
</table>

The scopeFace component takes in the current row,column coordinates of the 
display and generates the R,G,B values at that screen coordinate. For example,
if row,column = 20,20 then the R,G,B output should be 0xFF,0xFF,0xFF (white)
because the upper left corner of the O'scope grid display is white. 

<h3>The video_clk module</h3>
You will need to generate an IP core for this module usin the instructions 
in the "howTo 05 Instantiate Clock and HDMI IP" document posted on the 
main web page.

<h3>The hdmi_tx_0 module</h3>
You will need to generate an IP core for this module using the instructions 
in the "howTo 05 Instantiate Clock and HDMI IP" document posted on the 
main web page.

<h3>The scopeToHdmi package</h3>
You will need to complete the scopeToHdmi package linked above.  Include this
package in this lab's files and in later labs that use these components.


<h2>Required Functionality</h2>

<ol>

<li>You will be asked to show the following simulation results,
	<ul>	<li>Show a image of your simulation from 0 to 1.2us.  This should show the 
		first line of video with proper hs, h_activeArea, h_cnt and pixelHorz.
		<li>Show a image of your simulation from 0 to 550us.  This should show the 
		first 34 line of video with proper vs, v_activeArea, v_cnt and pixelVert.
		<li>Show a image of your simulation from 0 to 2ms.  This should show the 
		first non-zero RGB values being sent to the display.
	</ul>

<li>Your code must generate the thick white outline that defines the border
of the oscilloscope.  Draw grid in grey (R,G,B) = (0x40, 0x40, 0x40) so that
you have 10 horizontal and 10 vertical divisions.  Draw 4 hatch marks in grey
so they evenly split each vertical and horizontal division.  Draw the markers
as triangles in cyan (R,G,B) = (0x00, 0xFF, 0xFF).


<li>The ALINX board has four buttons that you are able to associate with
your design.  One of these buttons (PL Key 1) is dedicated to the resetn
function.  Use the remaining three keys to manipulate the Trigger Volt Mark
and the Trigger Time Mark as follows:

<ul>
<li>Pressing PL_KEY3 decreases the Trigger Volt Mark
<li>Pressing PL_KEY3 while holding PL_KEY2 increases the Trigger Volt Mark
<li>Pressing PL_KEY4 increases the Trigger Time Mark
<li>Pressing PL_KEY4 while holding PL_KEY2 decreases the Trigger Time Mark
</ul>

<li>Test the channel functions by:
<ul>
<li>Drawing the channel 1 trace (yellow) along a diagonal where (row = column).
<li>Drawing the channel 2 trace (green) along a horizontal at the same level as
the voltage trigger.
</ul>

</ol>


<h2>Simulation</h2>
You will need to run simulations to make sure that all your 
videoSignalGenerator is producing the correct waveforms.  I've 
included a testbench file and TCL setup script to help you setup
the testbench.  The images below are from my simulation output.
You signals may differ slightly in their timing and your 
videoSignalGenerator will function just fine.  The RGB signal
output really depends on your scopeFace and may differ quite
a bit from what my setup generated.

<table class="table table-striped table-bordered table-condensed">
<tr><td>Signal		<td>Color	<td>Radix
<tr><td>clk		<td>Green	<td>binary
<tr><td>resetn		<td>Green	<td>binary
<tr><td>h_cnt		<td>Yellow	<td>unsigned
<tr><td>pixelHorz	<td>Yellow	<td>unsigned
<tr><td>h_activeArea	<td>Yellow	<td>binary
<tr><td>hs		<td>Yellow	<td>binary

<tr><td>v_cnt		<td>Yellow	<td>unsigned
<tr><td>pixelVert	<td>Yellow	<td>unsigned
<tr><td>v_activeArea	<td>Yellow	<td>binary
<tr><td>vs		<td>Yellow	<td>binary

<tr><td>de		<td>Green	<td>binary
<tr><td>red		<td>Red		<td>Hexadecimal
<tr><td>green		<td>Green	<td>Hexadecimal
<tr><td>blue		<td>Blue	<td>Hexadecimal
</table>

To help you in debugging, I've provided some excerpts from my 
testbench simulation.  If you right-click on the images and
open in a new window, they will enlarge.

<table class="table table-striped table-bordered table-condensed">
<tr>
	<td>At 10us  </td>
	<td> <img width=300 src="./img/simAt10us.jpg"> </td> 
	<td>This shows the clock starting up and the first few hcounts.</td></tr> 

<tr>	<td>At 11.5us  </td>
	<td> <img width=300 src="./img/simAt12us.jpg"> </td> 
	<td>This shows the horizontal synch dropping low at h_cnt = 110 and 
	rising high at ih_cnt = 150.  </td></tr> 

<tr>	<td>At 32.5us </td>
	<td>  <img width=300 src="./img/simAt32500ns.jpg"></td>
	<td>This shows h_cnt starting over after counting up to 1649.</td> </tr> 

<tr>	<td>Up to 700us </td>
	<td>  <img width=300 src="./img/simTo700us.jpg"></td> 
	<td>This shows the first few rows of video with a proper vsynch and v_active area. </tr>

<tr>	<td>At 3ms </td>
	<td>  <img width=300 src="./img/simAt3ms.jpg"></td> 
	<td>This shows the top border of scopeFace being displayed. </tr>

</table>


Show a image of your simulation from 0 to 2ms.  This should show the 
first non-zero RGB values being sent to the display.


<h2>Connecting</h2>
Your ALINX board will need to connect to the HDMI port, the JTAG programming 
port and the power supply. The image below shows how I made these connections.
The reset and trigger control buttons assigned in the XDC file are also shown.
<br><img src="./img/board.jpg"><br><br>

        </div>
    </body>
</html>

